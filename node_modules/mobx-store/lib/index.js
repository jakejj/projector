'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.default = function () {
  var intitialState = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var userConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var config = (0, _extends3.default)({
    historyLimit: Infinity,
    noHistory: false
  }, userConfig);

  var create = config.noHistory ? createDataWithoutHistory : (0, _lodash.partialRight)(createData, config.historyLimit);

  // Store API
  db.canRedo = function (key) {
    return db.object.get(key).__future.length > 0;
  };
  db.canUndo = function (key) {
    return db.object.get(key).__past.length > 0;
  };
  db.contents = function () {
    return (0, _mobx.toJS)(db.object);
  };
  db.set = (0, _mobx.action)(function (key, value) {
    return db.object.set(key, create(value));
  });
  db.redo = (0, _mobx.action)(redo);
  db.undo = (0, _mobx.action)(undo);
  db.chain = chain;
  db.fromObject = fromObject;
  db.object = fromObject(intitialState);
  db.schedule = schedule;

  // Query the DB, allowing the user to chain functions to query the store
  function db(key, funcs) {
    if (!db.object.get(key)) throw new Error('Tried to retrieve undefined key: ' + key);
    if (funcs) {
      return chain(db.object.get(key), funcs);
    }
    return db.object.get(key);
  }

  // Redo any undone changes to the given store
  function redo(key) {
    var obs = db.object.get(key);
    if (!db.canRedo(key)) {
      throw new Error('You cannot call redo without having called undo first');
    }

    // Redo shouldn't trigger a push to history
    obs.__trackChanges = false;
    obs.__past.push(revertChange(obs.__future.pop()));
  }

  // Undo any changes the user has made to the current store
  function undo(key) {
    var obs = db.object.get(key);
    if (!db.canUndo(key)) {
      throw new Error('You cannot call undo if you have not made any changes');
    }

    // Undo shouldn't trigger a push to history
    obs.__trackChanges = false;
    obs.__future.push(revertChange(obs.__past.pop()));
  }

  function fromObject(obj) {
    return (0, _mobx.observable)((0, _mobx.asMap)((0, _lodash.mapValues)(obj, function (value) {
      return create(value);
    })));
  }

  // Return the database object
  return db;
};

exports.chain = chain;
exports.schedule = schedule;

var _lodash = require('./lodash');

var _mobx = require('mobx');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Chain multiple lodash/fp functions together to allow declarative querying
function chain(data, funcs) {
  var chainData = data;
  if (data.constructor.name === 'ObservableArray') {
    chainData = data.slice();
  } else if (data.constructor.name === 'ObservableMap') {
    chainData = data.toJS();
  }
  return _lodash.flow.apply(undefined, (0, _toConsumableArray3.default)((0, _lodash.concat)([], funcs)))(chainData);
}

// Automatically run functions with given args when store mutates


function schedule() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return (0, _lodash.map)((0, _lodash.map)(funcs, function (args) {
    return _lodash.partial.apply(undefined, (0, _toConsumableArray3.default)(args));
  }), _mobx.autorun);
}

// Take a change event and revert it
function revertChange(change) {
  var obs = change.object;
  if (change.type === 'update') {
    var newChange = {
      object: change.object,
      type: 'update',
      name: change.name,
      index: change.index,
      oldValue: null
    };

    if (change.index !== undefined) {
      // Array
      newChange.oldValue = obs[change.index];
      obs[change.index] = change.oldValue;
    } else if (obs.constructor.name === 'ObservableMap') {
      // MobX Map
      newChange.oldValue = obs.get(change.name);
      obs.set(change.name, change.oldValue);
    } else {
      // MobX Object
      newChange.oldValue = obs[change.name];
      obs[change.name] = change.oldValue;
    }

    return newChange;
  }
  var removed = obs.splice.apply(obs, [change.index, change.addedCount].concat((0, _toConsumableArray3.default)(change.removed)));
  return {
    object: change.object,
    type: 'splice',
    removed: removed,
    index: change.index,
    addedCount: change.removed.length
  };
}

// Create a store entry such that the it has history that can be undo/redo
function createData(data, limit) {
  // Throw an error if the data isn't an array or object
  if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) !== 'object') throw new Error('Top level elements of the store need to be arrays or objects');

  // Create the observable with history
  var obs = (0, _mobx.observable)(Array.isArray(data) ? data : (0, _mobx.asMap)(data));
  connectParent(obs, obs);
  return (0, _defineProperties2.default)(obs, {
    __past: { value: [], writable: true },
    __future: { value: [], writable: true },
    __trackChanges: { value: true, writable: true },
    __limit: { value: limit }
  });
}

// Create a store entry
function createDataWithoutHistory(data) {
  // Throw an error if the data isn't an array or object
  if ((typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) !== 'object') throw new Error('Tried to create value with invalid type');
  return (0, _mobx.observable)(Array.isArray(data) ? data : (0, _mobx.asMap)(data));
}

// Spy on the changes
(0, _mobx.spy)(function (change) {
  if (!change.object || !change.object.__parent) return;

  // Add the event to the history
  var obs = change.object.__parent;
  if (obs.__trackChanges) {
    obs.__future = [];
    obs.__past.push(change);
    if (obs.__past.length > obs.__limit) obs.__past.shift();
  } else {
    obs.__trackChanges = true;
  }

  // If there was data added, tag all the new data with the parent
  switch (change.type) {
    case 'add':
      connectParent(change.newValue, obs);
      break;
    case 'splice':
      connectParent(change.added, obs);
      break;
    default:
      break;
  }
});

function connectParent(obj, parent) {
  if (!(0, _lodash.isObject)(obj)) return;
  if (obj.slice) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(obj), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var elem = _step.value;
        connectParent(elem, parent);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)((0, _lodash.values)(obj)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var value = _step2.value;
        connectParent(value, parent);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }if (!obj.__parent) Object.defineProperty(obj, '__parent', { value: parent });
}